//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Interpolate50_D"
	Revision           = "1.6"
	GUID               = "{417AF322-D470-11D5-BDB2-000103C6CD0D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Interpolate50_D\interpol.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "Class to interpolate a value [DINT] with a table (with 50 tableformat and DINTvalues)">
	<Channels>
		<Server Name="Error_S" GUID="{1419FC92-D823-11D5-BDB2-000103C6CD0D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0-&gt; OK    &#13;&#10;1-&gt; value too low&#13;&#10;2-&gt; value too high&#13;&#10;3-&gt; other error (e.g. wrong table)"/>
		<Server Name="result" GUID="{417AF323-D470-11D5-BDB2-000103C6CD0D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="interpolated value"/>
		<Client Name="table" Required="true" Internal="false" Comment="pointer of table"/>
		<Client Name="value" Required="true" Internal="false" Comment="The value to be interpolated"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.6" Date="2020-10-29" Author="KneMar" Company="Sigmatek" Description="Fixed the case if the input value was higher than- or by 1 lower than- the maximum value given in the table, the class would return the wrong value."/>
		<Dokumentation Revision="1.5" Date="2013-06-27" Author="spimar" Company="Sigmatek" Description="ARM ready"/>
		<Dokumentation Revision="1.4" Date="30.04.09" Author="hötant" Company="Sigmatek" Description="Changed LSL_TARGETARCH_ARM to _LSL_TARGETARCH_ARM"/>
		<Dokumentation Revision="1.3" Date="04.02.09" Author="hötant" Company="Sigmatek" Description="AWL to ST (to guarantee compatibility for other processors) "/>
	</RevDoku>
</Class>
*)
Interpolate50_D : CLASS
  //Servers:
	result 	: SvrChCmd_DINT;
	Error_S 	: SvrCh_DINT;
  //Clients:
	value 	: CltCh_DINT;
	table 	: CltCh_DINT;
  //Variables:
  //Functions:
				//! <Function Comment="//*********************************************************************&#13;&#10;//         Function to interpolate a [INT]-value into a table&#13;&#10;//*********************************************************************&#13;&#10;//     ATTENTION: only for &quot; INT &quot; values&#13;&#10;//*********************************************************************&#13;&#10;//  INPUT_VAL&#13;&#10;//              pTable    : ^DINT : pointer to the table&#13;&#10;//              value_in  : DINT  : Wert für Interpolation&#13;&#10;//&#13;&#10;//  OUTPUT_VAL  &#13;&#10;//              value_out : DINT  : interpolated value&#13;&#10;//*********************************************************************&#13;&#10;//  created RM : KW46&#13;&#10;//*********************************************************************&#13;&#10;&#13;&#10;" Name="intpol_50_D"/>
	FUNCTION AWL GLOBAL intpol_50_D
		VAR_INPUT
			ptr 	: ^DINT;			//! <Variable Comment="pointer to the table" Name="intpol_50_D.ptr"/>
			value_In 	: DINT;			//! <Variable Comment="value that should be interpolated" Name="intpol_50_D.value_In"/>
		END_VAR
		VAR_OUTPUT
			value_out 	: DINT;			//! <Variable Comment="the interpolated value" Name="intpol_50_D.value_out"/>
		END_VAR;
	
	FUNCTION GLOBAL intpol_50_D_ST
		VAR_INPUT
			ptr 	: ^DINT;
			value_In 	: DINT;
		END_VAR
		VAR_OUTPUT
			value_out 	: DINT;
		END_VAR;
				//! <Function Comment="//*********************************************************************&#13;&#10;//         Function to read the interpolated value&#13;&#10;//*********************************************************************&#13;&#10;//     ATTENTION: only for &quot; DINT &quot; values&#13;&#10;//*********************************************************************&#13;&#10;//  VAR_Output : value  : interpolated value&#13;&#10;//           &#13;&#10;//&#13;&#10;//*********************************************************************&#13;&#10;//  created:RM:KW46&#13;&#10;//*********************************************************************&#13;&#10;&#13;&#10;&#13;&#10;     created  :   RM   :   KW46&#13;&#10;*********************************************************************&#13;&#10;" Name="result.Read"/>
	FUNCTION VIRTUAL GLOBAL result::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Interpolate50_D::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_INTERPOLATE50_D
1$UINT, 6$UINT, (SIZEOF(::Interpolate50_D))$UINT, 
2$UINT, 2$UINT, 0$UINT, 
TO_UDINT(740844382), "Interpolate50_D", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Interpolate50_D.result.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3817997973), "result", 
(::Interpolate50_D.Error_S.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3955508119), "Error_S", 
//Clients:
(::Interpolate50_D.value.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3928201860), "value", 
(::Interpolate50_D.table.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(24989174), "table", 
END_FUNCTION


#define USER_CNT_Interpolate50_D 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Interpolate50_D] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Interpolate50_D::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Interpolate50_D, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	result.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF result.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Error_S.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Error_S.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\C_Interpolate50_D.st*********************


//[#ENGLISH]
//*********************************************************************
//         Function to read the interpolate value
//*********************************************************************
//		   ATTENTION: only for " DINT " values
//*********************************************************************
//  VAR_Output : value  : interpolated value
//           
//
//*********************************************************************
//  		 created		:		 RM		 :			KW46
//*********************************************************************

FUNCTION VIRTUAL GLOBAL Interpolate50_D::result::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

  // reading clients
	value := value.read();   
  
  table := table.read();
    
	// interpolate
  //result:= intpol_50_D(ptr:=table$^DINT, value_in:=value);   

  result:= intpol_50_D(ptr:=table$^DINT, value_in:=value);

  output := result;

END_FUNCTION //VIRTUAL GLOBAL interpolate_D::Read

#ifdef _LSL_TARGETARCH_ARM

FUNCTION GLOBAL Interpolate50_D::intpol_50_D
VAR_INPUT
  ptr 	: ^DINT;
  value_In 	: DINT;
END_VAR
VAR_OUTPUT
  value_out 	: DINT;
END_VAR
VAR
	dBasepoints : DINT;
  dMaxVal     : DINT;
  dHelp       : REAL;
  pVal        : ^DINT;
  x1          : REAL;
  vOutReal    : REAL;  
END_VAR
  
  if (ptr = NIL) then
 
    return;
  end_if;
 
  // pointer to first table entry
  ptr := ptr + sizeof(UDINT);

  if (value_In < ptr^) then
  
    if (value_In >= 0) then
  
      if (((ptr + 4)^ = 0) | (ptr^ < (ptr + 4)^) | (ptr^ = 0)) then
        
        // division error
        
        // set error server 3
        Error_S := 3;
        
        // set output value
        value_out := 16#FFFFFFFF$DINT;
        
      else
      
        Error_S := 0;
    
        dMaxVal := ptr^ - 1;
        
        dBasepoints := (ptr + 4)^ + 1;
    
        dHelp := to_REAL(dMaxVal) / (dBasepoints - 1);
        
        pVal := ptr + 8 + ((value_In * (dBasepoints - 1) / (dMaxVal)) * sizeof(DINT));
        
        x1 := (value_In * (dBasepoints - 1) / (dMaxVal)) * dHelp;
        
        vOutReal := pVal^ + (((pVal + 4)^ - pVal^) * (value_In - x1)) / dHelp;
        
        value_out := to_dint(vOutReal);
        
      end_if;
    else
      
      // set error server 1
      Error_S := 1;
      
      // output value = first value
      value_out := (ptr + 8)^;
    end_if;
  else
    
    // set error server 2
    Error_S := 2;
    
    // set output value = highest value
    value_out := (ptr + (((ptr + 4)^ + 2) * sizeof(DINT)))^;
    
  end_if;

END_FUNCTION

//[#ENGLISH]
//*********************************************************************
//         Class to interpolate a [DINT]-value into a table
//*********************************************************************
//		   ATTENTION: only for " DINT " values
//*********************************************************************
//  CLIENT : value  : value which has to be interpolated
//           table  : ptr on table
//  
//  Server : result : interpolated value
//                           
//           Error_S: 0-> OK
//                    1-> value too low
//					          2-> value too high
//					          3-> DIVERROR: reason: wrong table (INT:DINT)
//
// *********************************************************************
// * 		created			: 		RM  	:      		KW45
// *********************************************************************
//[#DEUTSCH]
//*********************************************************************
//       Interpolationsklasse zum Werteerstellen aus Stützpunkten
//                         einer Tabelle.
//*********************************************************************
// 					ACHTUNG: NUR FUER  " DINT "  WERTE
//*********************************************************************
//  CLIENT : value  : zu interpolierender Wert
//           table  : Pointer auf die Tabelle
//
//  Server : result : Interpolierter Wert
//                           
//           Error_S: 0-> OK
//                    1-> Wert ist zu niedrieg
//                    2-> Wert ist zu hoch
//					          3-> DIVERROR: mögliche Ursache: falsche Tabelle
//
//*********************************************************************
//  		 created		:		 RM		 :			KW46
//*********************************************************************

 


//[#ENGLISH]
//*********************************************************************
//         Function to interpolate a [INT]-value into a table
//*********************************************************************
//		   ATTENTION: only for " INT " values
//*********************************************************************
//  INPUT_VAL   pTable 	  : ^DINT : pointer to the table
//              value_in  : DINT  : Wert für Interpolation
//
//  OUTPUT_VAL  value_out : DINT  : interpolated value
//*********************************************************************
//  		 created    RM		 :			KW46
//*********************************************************************
#else

FUNCTION AWL Interpolate50_D::intpol_50_D
VAR_INPUT
	ptr		: ^DINT;
	value_In		: DINT;
END_VAR
VAR_OUTPUT
	value_out		: DINT;
END_VAR


  PUSH      EAX
  PUSH      ECX

  L.EDI     ptr
  L.EAX     value_in

  CMP.EAX  	(EDI+004)		// lower then the highest
  JL     	_lower			
  L.ECX   (EDI+008)
  L.EAX		(EDI + 012 + ECX * sizeof(DINT)) // KneMar Show the MaxOutput instead of MaxInput
  L.D	    Error_S, 002	 
  JMP      	_D_IPOLEND        


_lower   
  
  CMP.EAX	000       		// higher then the lowest
  JGE		_D_IPOL1		
  L.EAX      (EDI+012)		// the first value
  L.D	    Error_S, 001	 
  JMP      	_D_IPOLEND        


_DIVERROR_D		 
  
  L.EAX      16#FFFFFFFF		
  L.D	    Error_S, 003
  JMP      	_D_IPOLEND  


_D_IPOL1 

  L.D	   Error_S, 000
  XCH.EAX   EBX
  L.EAX    (EDI+004)            // maximum value
		 
  CMP.D	  (EDI+008),0
  JE		  _DIVERROR_D	
		 
  CLR       EDX
 
 
  DIV.D    (EDI+008)            //  / number of basepoints  
		         
  XCH.EAX   EBX                 // EBX = divisor
		 
  OR.EBX	   EBX
  JZ		   _DIVERROR_D	

  CLR       EDX                 // int (x/div) = value nr
  DIV       EBX

  SHL.EAX   0000000002          // 4 Byte / value
  ADD.EDI   EAX

  L.EAX    (EDI+016)            // n1 -n
  SUB.EAX  (EDI+012)
  MUL       EDX                 // rest
  cdq                           // FK 1.2 AHÖ
  IDIV       EBX                // FK 1.2 AHÖ    DIV   EBX
  ADD.EAX  (edi+012)


_D_IPOLEND
  
  S.EAX     value_out
  
  POP       ECX       
  POP       EAX

END_FUNCTION //VIRTUAL GLOBAL interpolate_D::interpolate

#endif


