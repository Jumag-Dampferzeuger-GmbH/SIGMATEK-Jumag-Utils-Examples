//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SIG_GEN_IF_VERSION 1
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SignalGenerator"
	Revision           = "1.11"
	GUID               = "{2DD234D5-4A0F-466F-9CED-8A319412073E}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(516,120)"
	Comment            = "With this signalgenerator it is possible&#13;&#10;to generate the following signales:&#13;&#10;&#13;&#10;/|  =&gt; one periode of a sawtooth&#13;&#10;/\  =&gt; one periode of a triangle&#13;&#10;~   =&gt; one periode of a sinus&#13;&#10;_|- =&gt; one periode of a rectangle&#13;&#10;... =&gt; one periode of a table-signal">
	<Channels>
		<Server Name="Amplitude" GUID="{C449F33B-13F5-4C34-B2DE-D84657914109}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="SRam" Comment="highest amplitude of the signal&#13;&#10;(maximum = 2 000 000 000)"/>
		<Server
			Name           = "ClassSvr"
			GUID           = "{0A1673A9-F31C-4DC4-9F5D-E804AA1748F1}"
			Visualized     = "true"
			Initialize     = "true"
			WriteProtected = "false"
			Retentive      = "SRam"
			Comment        = "Use global methods, &#13;&#10;NewInst methods or &#13;&#10;server/client interface of class for changing its properties">
			<NewInst>
				<Function Name="startSignal" Comment="start signal generation">
				</Function>
				<Function Name="stopSignal" Comment="stop signal generation">
				</Function>
				<Function Name="resetSignal" Comment="reset internal values to initial state">
				</Function>
				<Function Name="setAmplitude" Comment="set maximum value">
					<InputParameter>
						<Parameter Name="Amplitude" Comment="maximum value [counts]"/>
					</InputParameter>
				</Function>
				<Function Name="setRefSignal" Comment="set cRefSignal to a value ( = signal offset )&#13;&#10;will only work if client is not connected!">
					<InputParameter>
						<Parameter Name="RefSignal" InitValue="0" Comment="signal offset [counts]"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="retvalue" Comment="0  .. value was set&#13;&#10;-1 .. client is connected, value was not set"/>
					</OutputParameter>
				</Function>
				<Function Name="setPeriodicTime" Comment="set the periodic time of the signal">
					<InputParameter>
						<Parameter Name="PeriodicTime" Comment="time for one periode of the signal [ms]"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="retvalue" Comment="0  .. new periodic time is set&#13;&#10;-1 .. Periodic time of signal must at least be twice the cyclic time of the object!"/>
					</OutputParameter>
				</Function>
				<Function Name="setSignalTypeRectangle" Comment="set the signal type to rectangle&#13;&#10;if this changes the acutal signal internal values will be reset to initial values">
				</Function>
				<Function Name="setSignalTypeSawtooth" Comment="set the signal type to sawtooth&#13;&#10;if this changes the acutal signal internal values will be reset to initial values">
				</Function>
				<Function Name="setSignalTypeSine" Comment="set the signal type to sine&#13;&#10;if this changes the acutal signal internal values will be reset to initial values">
				</Function>
				<Function Name="setSignalTypeTriangle" Comment="set the signal type to triangle&#13;&#10;if this changes the acutal signal internal values will be reset to initial values">
				</Function>
				<Function Name="setSignalTypeUserTable" Comment="set the signal type to user-table&#13;&#10;if this changes the acutal signal internal values will be reset to initial values">
				</Function>
				<Function Name="setUserTable" Comment="set the pointer to a user defined table (tableformat 50D)">
					<InputParameter>
						<Parameter Name="ptrTable" InitValue="NIL" Comment="pointer to the table"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="retvalue" Comment=" 0 .. pointer is set&#13;&#10;-1 .. pointer is invalid&#13;&#10;-2 .. table is invalid (size does not fit)"/>
					</OutputParameter>
				</Function>
				<Function Name="getSignal" Comment="read the acutal value of the signal">
					<OutputParameter>
						<Parameter Name="retvalue"/>
					</OutputParameter>
				</Function>
				<Function Name="getInterfaceVersion" Comment="Read the version of the Interface-Commands&#13;&#10;Version is incremented on any change in behavoir of Interface-Commands!">
					<OutputParameter>
						<Parameter Name="InterfaceVersion" Comment="Actual version of interface commands"/>
					</OutputParameter>
				</Function>
			</NewInst>
		</Server>
		<Server Name="InterfaceVersion" GUID="{220958AC-943D-4F76-AD92-4AA197DE1B41}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="version of the class"/>
		<Server Name="Output" GUID="{1BC190DE-928A-4433-A66A-7AAB5BBED7FD}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The signal comes out here"/>
		<Server Name="PeriodicTime" GUID="{EDE4C578-C0B1-4219-B848-525815F75CD8}" Visualized="true" Initialize="true" DefValue="2000" WriteProtected="false" Retentive="SRam" Comment="the periodic time of the signal [ms]:&#13;&#10;/|  =&gt; one periode of a sawtooth&#13;&#10;/\  =&gt; one periode of a triangle&#13;&#10;~   =&gt; one periode of a sinus&#13;&#10;-|_ =&gt; one periode of a rectangle&#13;&#10;&#13;&#10;(minimum - 2 x tasktime)"/>
		<Server Name="Start" GUID="{4860C28A-0B45-4A9E-853B-811BA8CE058C}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Write an &quot;1&quot; on it, to start the&#13;&#10;generation of the signal"/>
		<Client Name="_Task" Required="false" Internal="false" Comment="This client is an object channel&#13;&#10;to _TaskObjectControl to call operating &#13;&#10;system methods."/>
		<Client Name="Ar_Sinus" Required="true" Internal="true"/>
		<Client Name="cImpuls" Required="false" Internal="false" Comment="everytime when a periode is finished, an&#13;&#10;impuls will be written to this client"/>
		<Client Name="cOutput" Required="false" Internal="false" Comment="the signal is written on this client"/>
		<Client Name="cRefSignal" Required="false" Internal="false" Comment="on this channel you can put for example&#13;&#10;an offset, or a signal, which will be&#13;&#10;superimposed with the new signal"/>
		<Client Name="cUserSignalTable" Required="false" Internal="false" Comment="connection to a user-defined table with 50D-Tableformat&#13;&#10;&#13;&#10;If a table is loaded the client shows the state of the table:&#13;&#10; 1 .. table is set to user defined table&#13;&#10; 0 .. pointer is set to default table&#13;&#10;-1 .. pointer is invalid&#13;&#10;-2 .. table is invalid (size does not fit)"/>
		<Client Name="Interpolate50_D" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="furluk"/>
		<Dokumentation Revision="1.11" Date="2019-07-03" Author="furluk" Company="Sigmatek" Description="a division with 0 was possible when determining the sign of the Amplitude&#13;&#10;the division with 0 is getting caught and the sign of the Amplitude is set to +"/>
		<Dokumentation Revision="1.10" Date="2013-12-12" Author="spimar" Company="Sigmatek" Description="- Changed names of global methods to first char is upper case&#13;&#10;- If periodic time is set to 0, a division by 0 was done&#13;&#10;- If Start is 0, the value 0 was written every cycle on cOutput"/>
		<Dokumentation Revision="1.1" Date="2012-07-19" Author="spimar" Company="Sigmatek" Description="Now it is possible to initialize the signal type (Server: ClassSvr) and the start command (Server: Start);"/>
		<Dokumentation Revision="1.0" Date="21.06.2010" Author="HasHan" Company="Sigmatek" Description="Release"/>
		<Dokumentation Revision="0.9" Date="03.06.2010" Author="BleErn" Company="Sigmatek" Description="added user-table-signal"/>
		<Dokumentation Revision="0.8" Date="02.06.2010" Author="HasHan" Company="Sigmatek" Description="First version"/>
	</RevDoku>
	<Network Name="SignalGenerator">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "Ar_Sinus"
				GUID       = "{23A45C33-FF1B-45A4-97D0-CC3731149747}"
				Class      = "Ar_Sinus"
				Position   = "(240,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="Value"/>
				</Channels>
			</Object>
			<Object
				Name       = "Interpolate50_D"
				GUID       = "{140CAD43-51B7-410D-89D3-07CB38BFF9A1}"
				Class      = "Interpolate50_D"
				Position   = "(240,270)"
				Visualized = "true">
				<Channels>
					<Server Name="Error_S"/>
					<Server Name="result"/>
					<Client Name="table" Value="0"/>
					<Client Name="value" Value="0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Ar_Sinus" Destination="Ar_Sinus.Data"/>
			<Connection Source="this.Interpolate50_D" Destination="Interpolate50_D.result"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
SignalGenerator : CLASS
	TYPE
	  CmdClassSvr :  //! <Type Public="true" Name="CmdClassSvr"/>
	  (
	    startSignal,
	    stopSignal,
	    resetSignal,
	    setAmplitude,
	    setRefSignal,
	    setPeriodicTime,
	    setSignalTypeRectangle,
	    setSignalTypeSawtooth,
	    setSignalTypeSine,
	    setSignalTypeTriangle,
	    setSignalTypeUserTable,
	    setUserTable,
	    getSignal,
	    getInterfaceVersion
	  )$UINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_SignalType;
	InterfaceVersion 	: SvrCh_DINT;
	Amplitude 	: SvrCh_DINT;
	PeriodicTime 	: SvrCh_UDINT;
	Start 	: SvrCh_DINT;
	Output 	: SvrCh_DINT;
  //Clients:
	_Task 	: CltChCmd__TaskObjectControl;
	cRefSignal 	: CltCh_DINT;
	cUserSignalTable 	: CltCh_DINT;
	cOutput 	: CltCh_DINT;
	Ar_Sinus 	: CltChCmd_Ar_Sinus;
	Interpolate50_D 	: CltChCmd_Interpolate50_D;
	cImpuls 	: CltCh_DINT;
  //Variables:
		pTable 	: ^UDINT;			//! <Variable Comment="pointer to user-defined signal-table&#13;&#10;default is table &quot;exampleSignalTable&quot;" Name="pTable"/>
		udActTime 	: UDINT;			//! <Variable Comment="actual time in periode" Name="udActTime"/>
		udTimeBase 	: UDINT;			//! <Variable Comment="actual time base of object [탎 or ms]" Name="udTimeBase"/>
		bIsMicrosecMode 	: BOOL;			//! <Variable Comment="is object task in microseconds" Name="bIsMicrosecMode"/>
		internPeriodicTime 	: UDINT;			//! <Variable Comment="intern periodic time [탎 or ms]" Name="internPeriodicTime"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="start signal generation" Name="StartSignal"/>
	FUNCTION GLOBAL StartSignal;
				//! <Function Comment="stop signal generation" Name="StopSignal"/>
	FUNCTION GLOBAL StopSignal;
				//! <Function Comment="reset internal values to initial state" Name="ResetSignal"/>
	FUNCTION GLOBAL ResetSignal;
				//! <Function Comment="set maximum value" Name="SetAmplitude"/>
	FUNCTION GLOBAL SetAmplitude
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="SetAmplitude.sdAmplitude"/>
		END_VAR;
				//! <Function Comment="set cRefSignal to a value ( = signal offset )&#13;&#10;will only work if client is not connected!" Name="SetRefSignal"/>
	FUNCTION GLOBAL SetRefSignal
		VAR_INPUT
			sdRefSignal 	: DINT;			//! <Variable Comment="signal offset [counts]" Name="SetRefSignal.sdRefSignal"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="0  .. value was set&#13;&#10;-1 .. client is connected, value was not set" Name="SetRefSignal.retvalue"/>
		END_VAR;
				//! <Function Comment="set the periodic time of the signal" Name="SetPeriodicTime"/>
	FUNCTION GLOBAL SetPeriodicTime
		VAR_INPUT
			udPeriodicTime 	: UDINT;			//! <Variable Comment="time for one periode of the signal [ms]" Name="SetPeriodicTime.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="0  .. new periodic time is set&#13;&#10;-1 .. Periodic time of signal must at least be twice the cyclic time of the object!" Name="SetPeriodicTime.retvalue"/>
		END_VAR;
				//! <Function Comment="set the signal type to rectangle&#13;&#10;if this changes the acutal signal internal values will be reset to initial values" Name="SetSignalTypeRectangle"/>
	FUNCTION GLOBAL SetSignalTypeRectangle;
				//! <Function Comment="set the signal type to sawtooth&#13;&#10;if this changes the acutal signal internal values will be reset to initial values" Name="SetSignalTypeSawtooth"/>
	FUNCTION GLOBAL SetSignalTypeSawtooth;
				//! <Function Comment="set the signal type to sine&#13;&#10;if this changes the acutal signal internal values will be reset to initial values" Name="SetSignalTypeSine"/>
	FUNCTION GLOBAL SetSignalTypeSine;
				//! <Function Comment="set the signal type to triangle&#13;&#10;if this changes the acutal signal internal values will be reset to initial values" Name="SetSignalTypeTriangle"/>
	FUNCTION GLOBAL SetSignalTypeTriangle;
				//! <Function Comment="set the signal type to user-table&#13;&#10;if this changes the acutal signal internal values will be reset to initial values" Name="SetSignalTypeUserTable"/>
	FUNCTION GLOBAL SetSignalTypeUserTable;
				//! <Function Comment="set the pointer to a user defined table (tableformat 50D)" Name="SetUserTable"/>
	FUNCTION GLOBAL SetUserTable
		VAR_INPUT
			ptrTable 	: ^void;			//! <Variable Comment="pointer to the table" Name="SetUserTable.ptrTable"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment=" 0 .. pointer is set&#13;&#10;-1 .. pointer is invalid&#13;&#10;-2 .. table is invalid (size does not fit)" Name="SetUserTable.retvalue"/>
		END_VAR;
				//! <Function Comment="read the acutal value of the signal" Name="GetSignal"/>
	FUNCTION GLOBAL GetSignal
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="acutal value of the signal [counts]" Name="GetSignal.retvalue"/>
		END_VAR;
				//! <Function Comment="generates a rectangle signal:&#13;&#10;half of the time on Amplitude&#13;&#10;and half of the time to -Amplitude" Name="Rectangle"/>
	FUNCTION Rectangle
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="Rectangle.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="Rectangle.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="Rectangle.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="Rectangle.retvalue"/>
		END_VAR;
				//! <Function Comment="generates a sawtooth signal:&#13;&#10;a ramp from 0 to Amplitude and&#13;&#10;then immediately to 0&#13;&#10;/|" Name="Sawtooth"/>
	FUNCTION Sawtooth
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="Sawtooth.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="Sawtooth.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="Sawtooth.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="Sawtooth.retvalue"/>
		END_VAR;
				//! <Function Comment="generates a sinus signal:&#13;&#10;~" Name="Sine"/>
	FUNCTION Sine
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="Sine.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="Sine.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="Sine.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="Sine.retvalue"/>
		END_VAR;
				//! <Function Comment="generates a triangle signal:&#13;&#10;ramp form 0 to Amplitude and back to 0&#13;&#10;/\" Name="Triangle"/>
	FUNCTION Triangle
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="Triangle.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="Triangle.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="Triangle.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="Triangle.retvalue"/>
		END_VAR;
				//! <Function Comment="generates a signal based on a user-defined table with 50D-tableformat" Name="UserTable"/>
	FUNCTION UserTable
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="UserTable.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="UserTable.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="UserTable.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="UserTable.retvalue"/>
		END_VAR;
				//! <Function Comment="method for calculation of signals&#13;&#10;may be derived!" Name="Calculation"/>
	FUNCTION VIRTUAL Calculation
		VAR_INPUT
			sdAmplitude 	: DINT;			//! <Variable Comment="maximum value [counts]" Name="Calculation.sdAmplitude"/>
			udActualTimeWithinPeriode 	: UDINT;			//! <Variable Comment="actual time within periode [탎 or ms]" Name="Calculation.udActualTimeWithinPeriode"/>
			udPeriodicTime 	: UDINT;			//! <Variable Comment="acutal periodic time [탎 or ms]" Name="Calculation.udPeriodicTime"/>
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;			//! <Variable Comment="signal without offset [counts]" Name="Calculation.retvalue"/>
		END_VAR;
	
	FUNCTION TAB exampleSignalTable;
				//! <Function Comment="Read the version of the Interface-Commands&#13;&#10;Version is incremented on any change in behavoir of Interface-Commands!" Name="GetInterfaceVersion"/>
	FUNCTION GLOBAL GetInterfaceVersion
		VAR_OUTPUT
			InterfaceVersion 	: DINT;			//! <Variable Comment="Actual version of interface commands" Name="GetInterfaceVersion.InterfaceVersion"/>
		END_VAR;
	
	FUNCTION setUserTableInternal
		VAR_INPUT
			ptrTable 	: ^void;
		END_VAR
		VAR_OUTPUT
			retvalue 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="change signal-type&#13;&#10;if signal type is changed internal values are reset to initial state" Name="ClassSvr.Write"/>
	FUNCTION VIRTUAL GLOBAL ClassSvr::Write
		VAR_INPUT
			input (EAX) 	: SignalType;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: SignalType;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Amplitude::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PeriodicTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Ar_Sinus
#pragma using Interpolate50_D
#pragma usingLtd _TaskObjectControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SignalGenerator::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SIGNALGENERATOR
1$UINT, 11$UINT, (SIZEOF(::SignalGenerator))$UINT, 
6$UINT, 7$UINT, 0$UINT, 
TO_UDINT(1162946096), "SignalGenerator", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SignalGenerator.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000001000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::SignalGenerator.InterfaceVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2728512522), "InterfaceVersion", 
(::SignalGenerator.Amplitude.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(795838206), "Amplitude", 
(::SignalGenerator.PeriodicTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(551131164), "PeriodicTime", 
(::SignalGenerator.Start.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1747818303), "Start", 
(::SignalGenerator.Output.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1009177368), "Output", 
//Clients:
(::SignalGenerator._Task.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(969819786), "_Task", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::SignalGenerator.cRefSignal.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3107177023), "cRefSignal", 
(::SignalGenerator.cUserSignalTable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(624262374), "cUserSignalTable", 
(::SignalGenerator.cOutput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1701560865), "cOutput", 
(::SignalGenerator.Ar_Sinus.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(528675999), "Ar_Sinus", TO_UDINT(528675999), "Ar_Sinus", 1$UINT, 2$UINT, 
(::SignalGenerator.Interpolate50_D.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(740844382), "Interpolate50_D", TO_UDINT(740844382), "Interpolate50_D", 1$UINT, 6$UINT, 
(::SignalGenerator.cImpuls.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1869583480), "cImpuls", 
END_FUNCTION


#define USER_CNT_SignalGenerator 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SignalGenerator] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SignalGenerator::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SignalGenerator, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Calculation();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Amplitude.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Amplitude::Write() );
	IF Amplitude.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PeriodicTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PeriodicTime::Write() );
	IF PeriodicTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Start.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Start.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL SignalGenerator::Init
  VAR
    sObjinfo  : LSLOBJ_INFO;
    retval    : DINT;
    pIntTable : ^void;
  END_VAR

  InterfaceVersion := getInterfaceVersion();

  if _firstscan then
    setUserTableInternal( ptrTable := #exampleSignalTable() );
    pIntTable := ( cUserSignalTable.Read() )$^UDINT;
    
    if IsClientConnected( #cUserSignalTable ) then
      setUserTable( ptrTable := pIntTable );
    end_if;

    retval := _Task.GetObjectInfo( thispointer := this, tasktype := OBJ_RT, objinfo := #sObjinfo );
    if retval = 0 then
      if ( sObjinfo.orgperiod AND 16#80000000 ) then
        udTimeBase := sObjinfo.orgperiod AND 16#7FFFFFFF;
        bIsMicrosecMode := true;
      else
        udTimeBase := sObjinfo.orgperiod;
        bIsMicrosecMode := false;
      end_if;
      
    end_if;
    
    setPeriodicTime(PeriodicTime);
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SignalGenerator::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	udHelpActTime : UDINT;
  END_VAR

  cRefSignal := cRefSignal.Read();
  
  if Start = 1 then
    udHelpActTime := ( udActTime + udTimeBase ) mod internPeriodicTime;
    cImpuls := 0;
    
    if udHelpActTime < udActTime then //When a periode is finished, an impuls will be written to the client
      cImpuls := 1;
    end_if;
    
    cImpuls.write(cImpuls);
    
    udActTime := udHelpActTime;
    
    cOutput := Output := Calculation( sdAmplitude := Amplitude,
                                      udActualTimeWithinPeriode := udActTime,
                                      udPeriodicTime := internPeriodicTime  ) + cRefSignal;
    cOutput.Write(cOutput);
  
  else
    if (Output <> 0) then
      cOutput := Output := 0;
      cOutput.Write(cOutput);

    end_if;
  end_if;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SignalGenerator::ClassSvr::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^Results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: IprStates;
  END_VAR

  case pPara^.uiCmd$CMDClassSvr of
    startSignal: //start the signal generation
      startSignal();
      
    stopSignal: //stop the signal generation
      StopSignal();
      
    resetSignal:
      resetSignal();
      
    setAmplitude://changing the amplitude
      setAmplitude( sdAmplitude := pPara^.aPara[0] );
      
    setRefSignal://changing the ref signal
      pResult^.aData[0]$DINT := setRefSignal( sdRefSignal:= pPara^.aPara[0] );
      pResult^.uiLng := sizeof( pResult^.uiLng ) + sizeof( DINT );
      
    setPeriodicTime://changing the periodic time
      pResult^.aData[0]$DINT := setPeriodicTime( udPeriodicTime := pPara^.aPara[0]$UDINT );
      pResult^.uiLng := sizeof( pResult^.uiLng ) + sizeof( DINT );
      
    setSignalTypeRectangle:
      setSignalTypeRectangle();
      
    setSignalTypeSawtooth:
      setSignalTypeSawtooth();
      
    setSignalTypeSine:
      setSignalTypeSine();
      
    setSignalTypeTriangle:
      setSignalTypeTriangle();
      
    setSignalTypeUserTable:
      setSignalTypeUserTable();
      
    getSignal:
      pResult^.aData[0]$DINT := getSignal();
      pResult^.uiLng := sizeof( pResult^.uiLng ) + sizeof( DINT );
      
    setUserTable:
      pResult^.aData[0]$DINT := setUserTable( ptrTable:= pPara^.aPara[0]$^void );
      pResult^.uiLng := sizeof( pResult^.uiLng ) + sizeof( ^void );
      
    getInterfaceVersion:
      pResult^.aData[0]$DINT := getInterfaceVersion();
      pResult^.uiLng := sizeof( pResult^.uiLng ) + sizeof( ^void );
      
  end_case;
  
  ret_code := READY;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::StartSignal

  Start := 1;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::StopSignal

  Start := 0;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::ResetSignal

  udActTime :=  0;
  cOutput := Output := 0;
  cOutput.Write(input:=cOutput);

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetAmplitude
	VAR_INPUT
		sdAmplitude 	: DINT;
	END_VAR
  
  if sdAmplitude < 2000000000 & sdAmplitude > 0 then
    Amplitude := sdAmplitude;
  end_if;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetRefSignal
	VAR_INPUT
		sdRefSignal 	: DINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  if IsClientConnected( #cRefSignal ) then
    TRACE0( "cRefSignal must not be connected when calling setRefSignal! Object: {0}", LSL_GetObjName( pThis:= this ) );
    retvalue := -1;
  else
    cRefSignal := sdRefSignal;
    retvalue := 0;
  end_if;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetPeriodicTime
VAR_INPUT
  udPeriodicTime 	: UDINT;
END_VAR
VAR_OUTPUT
  retvalue 	: DINT;
END_VAR

  retvalue := 0;

  if (udPeriodicTime = 0) then
    udPeriodicTime := (udTimeBase * 2);

  end_if;

  if bIsMicrosecMode then
    if udPeriodicTime * 1000 >= ( udTimeBase / 2 ) & udTimeBase <> 0 then
      internPeriodicTime := udPeriodicTime * 1000;
      PeriodicTime := udPeriodicTime;
    else
      retvalue := -1;
    end_if;
    
  else
    if udPeriodicTime >= ( udTimeBase / 2 ) & udTimeBase <> 0 then
      PeriodicTime := internPeriodicTime := udPeriodicTime;
    else
      retvalue := -1;
    end_if;
  end_if;
  
  if retvalue = -1 then
    TRACE0( "Periodic time OF signal must at least be twice the cyclic time OF the object! Object: {0}", LSL_GetObjName(pThis:=this));
  end_if;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetSignalTypeRectangle

  ClassSvr.Write( input:= Rectangle );

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetSignalTypeSawtooth

  ClassSvr.Write( input:= Sawtooth );

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetSignalTypeSine

  ClassSvr.Write( input:= Sine );

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetSignalTypeTriangle

  ClassSvr.Write( input:= Triangle );

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::GetSignal
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  retvalue := Output;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::GetInterfaceVersion
	VAR_OUTPUT
		InterfaceVersion 	: DINT;
	END_VAR
  
  InterfaceVersion := SIG_GEN_IF_VERSION;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SignalGenerator::ClassSvr::Write
  VAR_INPUT
    input (EAX) 	: SignalType;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: SignalType;
  END_VAR

  if input <> ClassSvr then
    resetSignal();
  end_if;
  
  result := ClassSvr := input;

END_FUNCTION


FUNCTION VIRTUAL SignalGenerator::Calculation
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR
  VAR
    lsdAmplitude : DINT;
    lsdSign : DINT;
  END_VAR
  
  //*****************************************************************************************************************\\
  //when the Amplitude is negativ, then the signal will be reflected by the x axis
  //*****************************************************************************************************************\\
  
  lsdAmplitude := abs( Amplitude );
  
  if (lsdAmplitude = 0) then
    lsdSign := 1;
  else
    lsdSign := Amplitude / lsdAmplitude; //remember the sign
  end_if;
  
  case ClassSvr of
    Rectangle:
      retvalue  := Rectangle( sdAmplitude, udActualTimeWithinPeriode, udPeriodicTime );
    Sine:
      retvalue  := Sine( sdAmplitude, udActualTimeWithinPeriode, udPeriodicTime );
    Sawtooth:
      retvalue  := Sawtooth( sdAmplitude, udActualTimeWithinPeriode, udPeriodicTime );
    Triangle:
      retvalue  := Triangle( sdAmplitude, udActualTimeWithinPeriode, udPeriodicTime );
    UserTable:
      retvalue  := UserTable( sdAmplitude, udActualTimeWithinPeriode, udPeriodicTime );
  end_case;
  
  retvalue *= lsdSign;

END_FUNCTION


FUNCTION SignalGenerator::Rectangle
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  if udActualTimeWithinPeriode < ( udPeriodicTime / 2 ) then
    retvalue := Amplitude;
  else
    retvalue := -Amplitude;
  end_if;

END_FUNCTION


FUNCTION SignalGenerator::Sawtooth
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  retvalue := DIV_AB_BY_C( A := to_DINT( udActualTimeWithinPeriode ),
                           B := sdAmplitude,
                          _C := to_DINT( udPeriodicTime ) );

END_FUNCTION


FUNCTION SignalGenerator::Sine
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR
  VAR
    sdHelp : DINT;
  END_VAR

  sdHelp := DIV_AB_BY_C(  A := 3600000,
                          B := to_DINT( udActualTimeWithinPeriode ),
                         _C := to_DINT( udPeriodicTime ) );
  retvalue := DIV_AB_BY_C(  A := Ar_Sinus.Data.Write( input := sdHelp ),
                            B := sdAmplitude,
                           _C := 100000 );

END_FUNCTION


FUNCTION SignalGenerator::Triangle
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  if udActualTimeWithinPeriode < ( udPeriodicTime / 2 ) then
    retvalue := DIV_AB_BY_C(  A := to_DINT( udActualTimeWithinPeriode ),
                              B := 2 * sdAmplitude,
                             _C := to_DINT( udPeriodicTime ) );
  else
    retvalue := Amplitude -
                DIV_AB_BY_C(  A := to_DINT( udActualTimeWithinPeriode - ( udPeriodicTime / 2 ) ),
                              B := 2 * sdAmplitude,
                             _C := to_DINT( udPeriodicTime ) );
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SignalGenerator::PeriodicTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  setPeriodicTime(udPeriodicTime:=input);
  result := PeriodicTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SignalGenerator::Amplitude::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  setAmplitude(sdAmplitude:=input);
 	result := Amplitude;

END_FUNCTION


FUNCTION SignalGenerator::UserTable
	VAR_INPUT
		sdAmplitude 	: DINT;
		udActualTimeWithinPeriode 	: UDINT;
		udPeriodicTime 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR
  VAR
    sdHelp : DINT;
    sdTableMaximum : DINT;
    sdI : DINT;
  END_VAR

(* 50D-Tableformat:

  pTable points to the size of the table in bytes as an UDINT
  pTable + SIZEOF(UDINT) therefore points to the first entry of the Table: maximum value + 1 as DINT
  pTable + SIZEOF(UDINT) + SIZEOF(DINT) therefore points to the second entry: number of points - 1 as DINT
  pTable + SIZEOF(UDINT) + SIZEOF(DINT) + SIZEOF(DINT) therefore goes to the first value as DINT and so on...

*)

  sdTableMaximum := 1;
  FOR sdI := 0 TO (pTable + SIZEOF(UDINT) + SIZEOF(DINT) )$^DINT^ DO
    IF ABS( (pTable + SIZEOF(UDINT) + SIZEOF(DINT) + SIZEOF(DINT) + SIZEOF(DINT) * sdI )$^DINT^ ) > sdTableMaximum THEN
      sdTableMaximum := ABS( (pTable + SIZEOF(UDINT) + SIZEOF(DINT) + SIZEOF(DINT) + SIZEOF(DINT) * sdI )$^DINT^ );
    END_IF;
  END_FOR;
  sdHelp := DIV_AB_BY_C(  A := ( pTable + SIZEOF(UDINT) )$^DINT^,
                          B := to_DINT( udActualTimeWithinPeriode ),
                         _C := to_DINT( udPeriodicTime ) );
  
  retvalue := DIV_AB_BY_C(  A := Interpolate50_D.intpol_50_D( ptr := pTable$^DINT, value_In := sdHelp ),
                            B := Amplitude,
                           _C := sdTableMaximum );

END_FUNCTION


FUNCTION TAB SignalGenerator::exampleSignalTable
 0601$DINT,  //MAX VALUE + 1
 0003$DINT,  //NUMBER OF VALUES - 1
 00000$DINT,
 00010$DINT,
 00100$DINT,
-01000$DINT,
END_FUNCTION


FUNCTION SignalGenerator::setUserTableInternal
	VAR_INPUT
		ptrTable 	: ^void;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  retvalue := -1;
  IF ptrTable <> NIL THEN
    retvalue := -2;
    IF ( ( ( ptrTable$^UDINT^ - SIZEOF(DINT) - SIZEOF(DINT) )$DINT / SIZEOF(DINT) ) - 1 ) = (ptrTable$^UDINT + SIZEOF(UDINT) + SIZEOF(DINT) )$^DINT^ THEN //Check if table is valid
      pTable := ptrTable$^UDINT;
      retvalue := 0;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetSignalTypeUserTable

  ClassSvr.Write( input:= UserTable );

END_FUNCTION


FUNCTION GLOBAL SignalGenerator::SetUserTable
	VAR_INPUT
		ptrTable 	: ^void;
	END_VAR
	VAR_OUTPUT
		retvalue 	: DINT;
	END_VAR

  retvalue := setUserTableInternal( ptrTable:= ptrTable );

  IF retvalue <> 0 THEN
    cUserSignalTable := retvalue;
  ELSE
    cUserSignalTable := 1;
  END_IF;

END_FUNCTION
